%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital,     %% The `digital` option enables the default options for the
               %% digital version of a document. Replace with `printed`
               %% to enable the default options for the printed version
               %% of a document.
%%  color,       %% Uncomment these lines (by removing the %% at the
%%               %% beginning) to use color in the printed version of your
%%               %% document
  oneside,     %% The `oneside` option enables one-sided typesetting,
               %% which is preferred if you are only going to submit a
               %% digital version of your thesis. Replace with `twoside`
               %% for double-sided typesetting if you are planning to
               %% also print your thesis. For double-sided typesetting,
               %% use at least 120 g/m² paper to prevent show-through.
  nosansbold,  %% The `nosansbold` option prevents the use of the
               %% sans-serif type face for bold text. Replace with
               %% `sansbold` to use sans-serif type face for bold text.
  nocolorbold, %% The `nocolorbold` option disables the usage of the
               %% blue color for bold text, instead using black. Replace
               %% with `colorbold` to use blue for bold text.
  lof,         %% The `lof` option prints the List of Figures. Replace
               %% with `nolof` to hide the List of Figures.
  lot,         %% The `lot` option prints the List of Tables. Replace
               %% with `nolot` to hide the List of Tables.
]{fithesis4}
%% The following section sets up the locales used in the thesis.
\usepackage{polyglossia}  %% By using `czech` or `slovak` as the
\setmainlanguage{czech} %% main locale instead of `english`, you
%% can typeset the thesis in either Czech or Slovak, respectively.
\setotherlanguages{english} %% The
%% additional keys allow foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\newfontfamily\russianfont[Script=Cyrillic,Ligatures=TeX]{PT Serif}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date        = \the\year/\the\month/\the\day,
    university  = mu,
    faculty     = fi,
    type        = bc,
    department  = Katedra strojového učení a zpracování dat,
    author      = Jiří Kyjovský,
    gender      = m,
    advisor     = {Ing. Matej Lexa, Ph.D.},
    title       = {Úložiště programů pro výuku bioinformatiky na FI MU},
    TeXtitle    = {Úložiště programů pro výuku bioinformatiky na FI MU},
    keywords    = {TODO},
    TeXkeywords = {TODO},
    abstract    = {%
      TODO
    },
    thanks      = {%
      TODO
    },
    bib         = bibliography.bib,
    %% Remove the following line to use the JVS 2018 faculty logo.
    facultyLogo = fithesis-fi,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
\usepackage[acronym]{glossaries}          %% The `glossaries` package
\renewcommand*\glspostdescription{\hfill} %% contains helper commands
\loadglsentries{example-terms-abbrs.tex}  %% for typesetting glossaries
\makenoidxglossaries                      %% and lists of abbreviations.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{listings} %% Source code highlighting
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
\usepackage[babel]{csquotes} %% Context-sensitive quotation marks
\begin{document}
%% Uncomment the following lines (by removing the %% at the beginning)
%% and to print out List of Abbreviations and/or Glossary in your
%% document. Titles for these tables can be changed by replacing the
%% titles `Abbreviations` and `Glossary`, respectively.
%% \clearpage
%% \printnoidxglossary[title={Abbreviations}, type=\acronymtype]
%% \printnoidxglossary[title={Glossary}]

\chapter*{Úvod}
\markright{\textsc{Úvod}}
\addcontentsline{toc}{chapter}{Úvod}

TODO na konci bakalarky


% ==================================================================================== %
% ==================================================================================== %


\chapter{Aktuální stav}

Studenti bioinformatiky na FI potřebují ke svému studiu využívat různý
bioinformatický software, stejně tak vyučující pro výuku. Některý software
je snadno přístupný a může být nainstalován přímo z repozitáře
distribuce, která je používána studentem, nebo je dostupný z nějakého jiného
repozitáře jako je například PyPI. Ne všechen potřebný software je takto dostupný
a studenti či vyučující by si museli daný software zkompilovat. Fakulta proto 
provozuje vitruální stroj s operačním systémem Bio-Linux \cite{biolinux_fi},
který byl využíván pro účely výuky, na nějž se mohou studenti připojit a
pracovat tam.

% ------------------------------------------------------------------------------------ %

\section{Seznámení se s problémem}

Bio-Linux, distribuce Linuxu na bázi Ubuntu 14.04 LTS, byl projektem snažícím se poskytnout
potřebnou množinu programů pro uživatele zajímající se o bioinformatiku
\cite{biolinux}. Tato distribuce se bohužel již od roku 2019 nachází ve stavu 
EOL\footnote{EOL znamená End of Life} \cite{biolinux_distrowatch}, čímž vznikla 
nutnost jej nahradit, jelikož provozování softwaru, který je ve stavu EOL, může
vést k nepříjemnostem \cite{eol}. Je tedy potřeba studentům a vyučujícím na FI
poskytnout nějakou základní množinu bioinformatického softwaru, který by byl již
zabalen a připraven k instalaci na zařízení pro potřeby výuky a nahradit tak 
zastaralý Bio-Linux.

Úkolem bakalářské práce tedy bylo navrhnout vhodné řešení k
zabalení softwaru, vytvořit nebo využít nějaké úložiště pro tyto balíčky,
poskytnout uživatelsky přívětivou cestu, jak si balíčky stáhnout a nainstalovat je
na zařízení. Dále bylo potřeba navrhnout celý systém tak, aby do něj mohl být dle
potřeby okamžitě přidán či aktualizován software potřebný pro výuku. Celý systém
by neměl být náročný na údržbu nebo aktualizace a přidávání softwaru by mělo být
jednoduché, aby s tím neměl vyučující potíže. Takto připravený software se pak
navíc může nainstalovat na nový virtuální stroj, který bude fakulta provozovat
jako v případě Bio-Linuxu.

% ------------------------------------------------------------------------------------ %

\section{Ubuntu}

TODO aktualni stav bioinforrmatickych baliku v ubuntu a balikovani v ubuntu obecne


% ------------------------------------------------------------------------------------ %

\section{Fedora}

TODO aktualni stav bioinforrmatickych baliku ve fedora a balikovani ve fedore obecne


\subsection{Copr}
\label{item:1.3.1}

% ------------------------------------------------------------------------------------ %

\section{Conda}

TODO aktualni stav bioinforrmatickych baliku pro condu a baleni conda nastroju


\subsection{Conda-forge}


% ==================================================================================== %
% ==================================================================================== %


\chapter{Návrh softwarového repozitáře}

Hlavní motivací při návrhu celého systému bylo použít co nejvíce fungujících
nástrojů a služeb a ty spojit dohromady tak, aby vytvořily celistvý celek. Tím pádem
jsem se mohl soustředit co nejvíce na automatizaci a zpříjemnění interakce se systémem
pro jeho uživatele. Celý systém jsem tedy rozdělil do čtyř hlavních komponent:

\begin{itemize}
    \item[\textbf{Build systém}] Jádro celého systému. Služba, která bude 
    schopna sestavit balíček z daného softwaru a tento balíček vrátit.
    \item[\textbf{Úložiště}] Databáze, která bude obsahovat již sestavené balíčky,
    vrácené z build systému, které jsou připraveny k instalaci na zařízení uživatele.
    \item[\textbf{Služba pro interakci správce se systémem}] Pomocí této služby
    bude správce komunikovat s build systémem a databází v intuitivní a abstraktní
    rovině. Detaily build systému nebo databáze zůstanou správci skryty.
    \item[\textbf{Sada nástrojů pro interakci}] Doplňující množina nástrojů, již
    existující nebo mnou vytvořená, která bude spojovat tři výše zmíněné komponenty
    do funkčního celku.
\end{itemize}

Zavedl jsem pohledy správce a uživatele na systém a podle nich jsem postupoval nezávisle
na zvolení build systému nebo úložiště tak, aby bylo těmto pohledům vyhověno a zároveň
abych mohl později zvolit vhodný build systém s úložištěm.

% ------------------------------------------------------------------------------------ %

\section{Pohled uživatele}

Instalace softwaru z pohledu uživatele musí být co nejméně náročná. Zároveň
se nesmí na uživatele přenášet žádné složitější úkony, aby byla práce
se systémem co nejjednodušší. V ideálním případě by měl být celý systém
navržen tak, aby si uživatel nainstaloval software pomocí jediného příkazu
v terminálu.

V případě interakce uživatele s virtuálním strojem musí být tento stroj rovnou
připravený k používání poté, co se k němu uživatel připojí, což znamená, že
množina softwaru musí být na virtuálním stroji již předinstalována.

% ------------------------------------------------------------------------------------ %

\section{Pohled správce}

Správce bude mít za úkol přidávat nový software do systému, případně jej
může aktualizovat. Po přidání nového softwaru nebo jeho aktualizace se
spustí série automatizovaných úkonů, které zaručí, že software bude
správně zabalen a bude dostupný uživateli k instalaci.

Aktualizace softwaru by neměla být primární zodpovědnost správce, systém
totiž bude periodicky kontrolovat nové verze softwaru a pokusí se je
sám aktualizovat. V případě neúspěchu bude správce o tomto skutku
kontaktován prostřednictvím emailu.

% ------------------------------------------------------------------------------------ %

\section{Repozitář metadat}

Pro interakci mezi správcem a systémem jsem se rozhodl použít podobný
koncept, který používá Flathub, což je schraňování potřebných metadat
aplikace, jako je například seznam závislostí nebo zdroj upstreamu, v
git repozitáři. Odsud se aplikace automatizovanou cestou díky
poskytnutým metadatům sestaví a odešle na úložiště Flathubu.
Přidání nové aplikace se řeší přes pull request na GitHubu 
a po schválení administrátory se vytvoří nový repozitář v organizaci
\textit{github.com/flathub}
\cite{flatpak_app_creation, flatpak_app_repo, flatpak_app_build}, do
kterého mají administrátoři přístup a mohou daný software dále
aktualizovat přes pull requesty v jejich přiděleném repozitáři pro
danou aplikaci \cite{flatpak_app_update}.

Podobný koncept však není nic nového. Například Fedora používá pro
ukládání metadat také řešení na konceptu gitu a říká jí 
dist-git \cite{dist-git}. Všechna metadata balíčků má uložené ve
své vlastní git službě\footnote{Dostupné na 
\url{https://src.fedoraproject.org/}}. Conda-forge také používá
podobné řešení na GitHubu\footnote{Všechny balíčky jsou dostupné
na \url{https://github.com/orgs/conda-forge/repositories}} jako
Flathub \cite{conda-forge_repo_creation}.


\subsection{Struktura úložiště metadat}
\label{item:2.3.1}

Stejně jako v případě řešení Flathubu jsem se rozhodl ukládat metadata
balíčků na GitHubu, kde správce bude moct pomocí pull requestu přidávat
nové balíčky nebo ty stávající aktualizovat.

Pro jednoduchost jsem nepoužil myšlenku jeden repozitář - jeden balíček,
nýbrž všechny balíčky budou skladovány v jednom velkém repozitáři, kde
každý příslušný balíček bude mít svou větev. Rozdělení 
každého balíčku do separátního repozitáře je vhodné pro situaci, kde
máme mnoho správců starající se o své balíčky a jiné je nezajímají.
Toto rozdělení zajišťuje oddělené práva přístupu. Naproti tomu v
našem případě se o balíčky bude starat pouze jedna entita a to je
fakulta, takže pro správce bude jednodušší, když bude mít všechny
své balíčky na jednom místě.

Obsahem každé větve budou nějaké předdefinované soubory jako 
\textbf{README.md} nebo soubory obsahující CI konfigurace. Dále bude 
každá větev obsahovat soubor s metadaty balíčku nazývající se
\textbf{metadata.yaml}.

\begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.6\textwidth]{images/png/repository_structure.png}
    \end{center}
    \caption{Ukázka struktury jedné větve GitHub repozitáře}
    \label{fig:repository_structure}
\end{figure}


\subsection{Metadata balíčku}

Jak můžeme vidět na obrázku \ref{fig:repository_structure}, každý
balíček obsahuje soubor \textbf{metadata.yaml}, který specifikuje
určitá metadata:

\begin{itemize}
    \item[\textbf{maintainers}] Seznam správců, kteří zodpovídají za
    konkrétní balíček. Tento seznam bude u každého správce obsahovat
    jeho GitHub uživatelské jméno a email, který bude použit v případě
    potřeby komunikace.
    \item[\textbf{url}] URL odkud bude upstream daného balíčku dostupný 
    ke stažení.
    \item[\textbf{version}] Aktuální verze balíčku v době aktualizace
    nebo přidání. Podle téhle informace bude systém určovat, jestli je
    daný balíček aktuální.
    \item[\textbf{sha512}] Checksum, konkrétně typu SHA512, podle kterého
    si bude systém ověřovat pravost stáhnutého zdroje.
    \item[\textbf{autoupdate}] Výchozí hodnota nastavena na \textbf{True}.
    Určuje, jestli se má systém pokoušet balíček automaticky aktualizovat.
\end{itemize}


\subsection{Správa balíčků}

Jak již bylo zmíněno v sekci \ref{item:2.3.1}, správce bude interagovat
se systémem pomocí pull requestu. V případě přidání nového balíčku
správce vytvoří v upstream repozitáři novou větev. Její jméno se musí
shodovat se jménem balíčku. V této větvi správce u sebe lokálně vyplní
potřebná metadata a následně vytvoří pull request. Systém skrze GitHub
Action\footnote{CI$\backslash$CD systém od  GitHubu\cite{gh_actions}}
automaticky otestuje, jestli se balíček podaří sestavit. Pokud ano, může
správce pull request potvrdit a přes GitHub Actions se balíček pošle do
databáze tak, aby byl dostupný uživateli k instalaci. V případě aktualizace
bude celá situace obdobná, pouze správce upraví již existující metadata 
balíčku tak, aby se aktualizace správně sestavila. Pro minimalizaci
lidské chyby při manipulaci s lokálním git repozitářem bude celý
pracovní postup zapouzdřen do speciálního nástroje 
\textbf{alpa}\footnote{Vyvíjen na
\url{https://github.com/fedora-alternative-packaging/alpa}}.


\subsection{alpa}

Vkládání nových balíčků vyžaduje vytváření nových větví, přičemž
se větvení provádí pro nový balíček vždy z hlavní větve. Pro
vytváření pull requestů je nutné vytvořit ještě další novou
větev z větve balíčku a následně ji s ní sjednotit. Takovýto
postup se lehce stane nepřehledným ve chvíli, kdy se v repozitáři
nachází spousta balíčků.

\begin{figure}[H]
    \begin{center}
      \includegraphics[width=1\textwidth]{images/png/feature_branch.png}
    \end{center}
    \caption{Feature větev balíčku}
    \label{fig:feature_branch}
\end{figure}

Pro vyvarování se chyb se špatnou prací s větvemi a celkově
lokálním git repozitářem jsem vytvořil nástroj \textbf{alpa},
který uživateli umožňuje komunikovat s repozitářem bez přímého
použití \textbf{git} nástroje a skrývá tak implementační detaily 
do pár jednoduchých příkazů:

\begin{itemize}
    \item[\textbf{create}] Vytvoří novou větev pro balíček za
    předpokladu, že správce má commit práva do softwarového repozitáře.
    \item[\textbf{request-package}] V případě, kdy uživatel nemá práva
    dělat commity v repozitáři, může poslat žádost o vytvoření
    větve pro balíček. Automat se postará o její vytvoření.
    \item[\textbf{delete}] Zažádá o smazání balíčku, ve kterém se
    zrovna uživatel nachází. O smazání v repozitáři se postará automat.
    \item[\textbf{switch}] Přepne větev repozitáře do větve uvedené 
    uživatelem. V případě dostupné \textit{feature branch} přepne do ní.
    \item[\textbf{show-history}] Ukáže historii commitů pouze daného
    balíčku, ve kterém se uživatel nachází.
    \item[\textbf{add}] Pouze obaluje funkcionalitu příkazu 
    \texttt{git add [soubory]}
    \item[\textbf{commit}] Spouští příkaz \texttt{git commit}. V
    případě, že se uživatel nenachází ve \textit{feature branch},
    přepne do ní nebo ji vytvoří.
    \item[\textbf{push}] Udělá \texttt{git push origin
    <feature-branch>:<větev-balíčku>} a připraví tak půdu pro
    následné vytvoření pull requestu oproti větve balíčku. Případně
    může uživatel explicitně zažádat přepínačem o automatické
    vytvoření pull requestu skrze GitHub API.
    \item[\textbf{update}] Aktualizuje aktuální balíček, ve kterém
    se uživatel nachází.
    \item[\textbf{clone}] Naklonuje a inicializuje repozitář.
    \item[\textbf{list}] Vypíše na výstup seznam balíčků v repozitáři.
    \item[\textbf{genspec}] Pokusí se uživateli na základě poskytnutých
    metadat vygenerovat spec soubor a pokud si uživatel zvolí, pokusí
    se jej i otestovat, jestli se balíček sestaví. Tento příkaz využívá
    různé existující generátory spec souborů jako je například
    \textbf{pyp2spec} \cite{pyp2spec}.
\end{itemize}


\subsection{Automatická aktualizace balíčků}

Systém bude periodicky hlídat upstream verzi balíčku\footnote{co měsíc/týden/den} 
a při zjištění nové verze se provede pokus o aktualizaci. Bohužel je nevýhodné
využít již navrženého schématu k aktualizaci skrze pull request kvůli
přísným limitům GitHubu na vytváření obsahu \cite{gh_secondary_rate_limits}
a velmi omezujícímu způsobu, jak se těmto chybám s limity vyhnout
\cite{gh_avoid_secondary_rate_limits}.

Pokus o aktualizaci se provede vytvořením nové větve a změnou atributu
\textbf{version} v metadatech balíčku na nejnovější verzi. Po aplikování
změn do této větve se nad ní spustí stejný CI systém, který testuje pull
requesty, jen se bude lišit spouštěč události, jenž bude \textbf{push} do
testovací větve \cite{gh_push_trigger}. Po úspěšném sestavení balíčku se 
testovací větev spojí s hlavní větví balíčku. Tak se vyhneme nutnosti vytvářet 
pull request. V případě neúspěchu bude kontaktován správce uvedený v metadatech
balíčku.


\subsection{Issue repozitář}

Pro sledování neaktuálních balíčků existuje separátní issue repozitář, kde
jsou vedeny záznamy o jednotlivých neúspěšně aktualizovaných a tedy neaktuálních
balíčcích. Tento repozitář umožní hlavnímu správci větší přehled o aktuálnosti
balíčků v repozitáři. Záznamy jsou vytvářeny automatizovaně při neúspěšné automatizované
aktualizaci balíčku a stejně tak jsou automatizovaně mazány v případě, že správce
balíček sám aktualizuje.


\subsection{Úložiště a build systém}

Systém separátně využije build systému, který sestavuje balíčky na základě
poskytnutých zdrojů a následně takto sestavený balíček vrátí, aby mohl být
uložen do nějaké databáze, odkud bude dostupný uživatelům k instalaci.
Implementace vlastního build systému je komplikovaný úkol a proto budou
databáze i build systém odděleny od GutHub repozitáře kvůli možnosti
využití již existujícího řešení. Komunikace mezi těmito systémy bude
zajištěna skrze GitHub Actions. Výběr build systému a k tomu vhodného
úložiště jsem diskutoval v následující kapitole.


% ==================================================================================== %
% ==================================================================================== %


\chapter{Zvolení build systému a úložiště}

Pro build systém a k tomu příslušné úložiště jsem se rozhodl vybírat mezi dvěma 
možnostmi. Jako první možnost, vzhledem k mé zkušenosti s balením softwaru do 
Fedory a obecně s balením RPM balíčků, jsem se rozhodl použít již dříve zmíněný 
Copr v sekci \ref{item:1.3.1}. Copr je řešení specifické, omezující se pouze na
některé Linuxové distribuce, byť umožňuje zabalit software do spousty distribucí
založených na RPM. Z tohoto důvodu jsem jako druhé řešení zvolil způsob, který
se nebude omezovat pouze na některé distribuce. 

Jako druhou možnost jak sestavovat balíčky jsem zvolil řešení, u kterého
nezáleží na konkrétní Linuxové distribuci jako u mého předchozího rozhodnutí.
K zabalení, nasazení a distribuci software napříč Linuxovými distribucemi
máme na výběr mezi třemi možnostmi a to Flatpak, Snap a AppImage.

K sestavování Flatpak nebo AppImage balíčků je možností použít službu Open
Build Service (dále jen OBS) \cite{obs}, která zároveň poskytuje funkcionalitu
balit software mimo jiné i do více formátů napříč různými distribucemi
\cite{obs_package_formats}. Zároveň, stejně jako Copr, slouží jako databáze
těchto sestavených balíčků připravených k instalaci, které si můžeme z jejich
databáze stáhnout a nainstalovat tak u sebe \cite{obs_flatpak}.


\section{Vyloučení Snapu}


\begin{markdown*}{%
  hybrid,
  definitionLists,
  footnotes,
  inlineFootnotes,
  hashEnumerators,
  fencedCode,
  citations,
  citationNbsps,
  pipeTables,
  tableCaptions,
}
```
TODO vysvetlit proc ne Snap... neexistuje zadna tak jednoducha sluzba jako OBS
nebo Copr, ktera by vybuildila snap. 
exituje https://snapcraft.io/docs/build-from-github a
https://snapcraft.io/docs/remote-build
ale cele se to nevyplati a skola by musela mit vlastni uloziste a hostovat repozitar
tady jsou linky jak udelat vlastni snap store a cele je to proste tezke
https://forum.snapcraft.io/t/how-to-host-your-private-store/1790
https://forum.snapcraft.io/t/external-repositories/1760/26
https://github.com/noise/snapstore
oficialni snap dokumentace k tomu:
https://docs.ubuntu.com/snap-store-proxy/en/install
https://ubuntu.com/core/docs/dedicated-snap-store
porovnani snap ofc storu a soukromych: mel by dost nevyhod -> nepouzitelny vcelku
https://ubuntu.com/core/services/guide/snap-store-vs-iot-app-store
https://ubuntu.com/core/services/guide/iot-app-store-intro
```
\end{markdown*}



% ------------------------------------------------------------------------------------ %

\section{Copr}

TODO tady bude popis toho jak funguje COPR

\subsection{Integrace pomocí Packitu}

% ------------------------------------------------------------------------------------ %

\section{OBS}

TODO tady bude popis toho jak by reseni fungovalo s flatpakem a appimage

flatpak a appimage buildy bude vytvaret  open build service od openSUSE

integrace s GH je o hodne pozadu oproti packitu
\text{https://openbuildservice.org/2021/05/31/scm-integration/}

\subsection{Flatpak}

\subsection{AppImage}

TODO tady napis ze AppImage se musi spustet rucne, byla by nutnost udelat nejaky
dalsi tool, ktery by byl basically takovy maly package manager - tzn ze by instaloval
programy tak aby se normalne daly pustit klasika a taky aby kontroloval aktualizace.
nebyl by to package manager v pravem slova smyslu, bo by neresil wbc dependency.
ale musel by resit aktualizace a je to nejaka praca navic.

\subsection{Integrace OBS s GitHubem}

% ==================================================================================== %
% ==================================================================================== %


\chapter{Srovnání metod}

V této části jsem se zaměřil na srovnání použitých metod z předchozí
kapitoly. Srovnával jsem na základě předem definovaných kritérií, zvážil
jejich výhody i nevýhody a následně vybral vhodnější metodu k implementaci
řešení.

% ------------------------------------------------------------------------------------ %

\section{Kritéria}

Pro výběr lepší metody je nutné zvolit kritéria, která budou zřetelně hodnotit
různé vlastnosti srovnávané metody. Zvolil jsem čtyři důležitá kritéria:
(TODO dohledat lepsi literaturu na tohle nez je ta aktualni a upravit to podle ni)

\begin{itemize}
    \item[\textbf{Nároky na údržbu}] Vzhledem k faktu, že správcem celého
    systému má být vyučující, musí být správa celého systému co nejméně
    časově náročná, ideálně bezúdržbová. Důraz bude kladen hlavně na části
    systému, které potenciálně vyžadují pravidelnou údržbu a také na části,
    které mohou selhat a bude třeba je znovu zprovoznit silami fakulty.
    \item[\textbf{Nároky na zdroje}] Zvolené řešení může potřebovat ke
    svému hladkému provozu nějaké zdroje, které mohou být například:
    úložiště, výpočetní výkon nebo potřeba dalšího správce, který by
    řešil problémy typu aktualizace celého systému a byl by schopen
    zprovoznit systém v případě, že by cokoliv selhalo. Zdroje fakulty
    samozřejmě nejsou neomezené a tedy řešení by mělo využívat dostupné
    zdroje fakulty střídmě a ideálně bez potřeby správce navíc.
    \item[\textbf{Uživatelská přívětivost}] V ideálním případě by si
    uživatel měl o nainstalování softwaru na své zařízení říct jedním 
    příkazem nebo pár kliknutími. Pokud by bylo komplikované software
    nainstalovat na zařízení uživatele, ztrácelo by to smysl.
    \item[\textbf{Proveditelnost}] A v neposlední řadě bych měl být schopen
    celý systém se zvolenou metodou implementovat v rozumném časovém 
    rozmezí, které je hodno bakalářské práci a to do takové podoby, ve které
    bude systém použitelný a nebo by mohla být nad systémem připravena další
    bakalářská práce, která by celý systém dokončila do použitelného stavu.
    V případě extrémní složitosti a časové náročnosti při  návrhu a
    implementaci systému jej nemá smysl dělat, jelikož by v tomto případě
    nemusel také být nikdy dokončen.
    \item[\textbf{Spolehlivost}]
\end{itemize}


% ------------------------------------------------------------------------------------ %

\section{Copr}

TODO srovnani vlastnosti copru s packitem

% ------------------------------------------------------------------------------------ %

\section{OBS}

TODO srovnani vlatnosti obs jako takoveho (slaba integrace CI a blabla)


\subsection{Flatpak}

TODO vyhodnoceni OBS + flatpak

\subsection{AppImage}

TODO vyhodnoceni Appimage + OBS

\subsection{TODO vybrani viteze mezi flatpakem a appimage}

TODO oba s tim ze se budou pouzivat spolecne s OBS

% ------------------------------------------------------------------------------------ %

\section{Výběr vhodné metody}

TODO sekce o vyberu mezi coprem a (flatpakem nebo appimage - vitez z vyse uvedeneho)
(spoiler: pouziju copr kvuli velmi slusne integraci s githubem pomoci packitu
coz usetri neskutecne moc prace - OBS nic takoveho nema)


% ==================================================================================== %
% ==================================================================================== %


\chapter{Implementace}

TODO tady budou detaily o implementaci a bla bla


% ==================================================================================== %
% ==================================================================================== %


\chapter*{Závěr}
\markright{\textsc{Závěr}}
\addcontentsline{toc}{chapter}{Závěr}

TODO na konci bakalarky

\printbibliography[heading=bibintoc] %% Print the bibliography.

\end{document}
